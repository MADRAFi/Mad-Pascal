// PETSCII codes
  PETSCII_SWAP_COLOR		      = $01;
  PETSCII_CLEAR	        		  = $93;
  PETSCII_BELL		            = $07;
  PETSCII_REVERSE_ON	        = $12;
  PETSCII_REVERSE_OFF	        = $92;
  PETSCII_ISO_ON	            = $0f;
  PETSCII_ISO_OFF	            = $8f;
  PETSCII_SWAP_LOWCHARSET     = $0e;
  PETSCII_SWAP_GFXCHARSET     = $8e;

  PETSCII_CURSOR_UP	          = $91;
  PETSCII_CURSOR_DOWN	        = $11;
  PETSCII_CURSOR_RIGHT        = $1d;
  PETSCII_CURSOR_LEFT         = $9d;
  PETSCII_KEY_ESCAPE	        = $1b;
  PETSCII_KEY_BACKSPACE	      = $14;
  PETSCII_KEY_DEL	            = $19;
  PETSCII_KEY_RETURN	        = $0d;
  PETSCII_KEY_SHIFT_RETURN	  = $8d;
  PETSCII_KEY_TAB	            = $09;
  PETSCII_KEY_SHIFT_TAB	      = $18;
  PETSCII_KEY_MENU	          = $06;
  PETSCII_KEY_HOME	          = $13;
  PETSCII_KEY_INSERT	        = $94;
  PETSCII_KEY_END	            = $04;
  PETSCII_KEY_HELP	          = $84;

  PETSCII_KEY_PAGEUP	        = $82;
  PETSCII_KEY_PAGEDOWN	      = $02;
  PETSCII_KEY_F1	            = $85;
  PETSCII_KEY_F2	            = $89;
  PETSCII_KEY_F3	            = $86;
  PETSCII_KEY_F4	            = $8a;
  PETSCII_KEY_F5	            = $87;
  PETSCII_KEY_F6	            = $8b;
  PETSCII_KEY_F7	            = $88;
  PETSCII_KEY_F8	            = $8c;
  PETSCII_KEY_F9	            = $10;
  PETSCII_KEY_F10	            = $15;
  PETSCII_KEY_F11	            = $16;
  PETSCII_KEY_F12	            = $17;

  PETSCII_COLOR_WHITE	        = $05;
  PETSCII_COLOR_RED           = $1c;
  PETSCII_COLOR_GREEN	        = $1e;
  PETSCII_COLOR_BLUE	        = $1f;
  PETSCII_COLOR_ORANGE	      = $81;
  PETSCII_COLOR_BLACK	        = $90;
  PETSCII_COLOR_BROWN	        = $95;
  PETSCII_COLOR_PINK	        = $96;
  PETSCII_COLOR_DARK_GREY	    = $97;
  PETSCII_COLOR_GREY	        = $98;
  PETSCII_COLOR_LIGHT_GREEN 	= $99;
  PETSCII_COLOR_LIGHT_BLUE	  = $9a;
  PETSCII_COLOR_LIGHT_GREY	  = $9b;
  PETSCII_COLOR_PURPLE	      = $9c;
  PETSCII_COLOR_YELLOW	      = $9e;
  PETSCII_COLOR_CYAN	        = $9f;


  ACPTR      = $ffa5; // ACPTR. Read byte from peripheral bus.
  BASIN	     = $ffcf; // Get character.
  BSAVE      = $feba; // Like SAVE but omits the 2-byte header.
  BSOUT	     = $ffd2; // Write byte in A to default output. For writing to a file must call OPEN and CHKOUT beforehand.
  CIOUT	     = $ffa8; // Send byte to peripheral bus.
  CLOSEALLCH = $ffe7; // CLALL. Close all channels.
  CLOSECH	   = $ffc3; // CLOSE. Close a channel.
  CHKIN      = $ffc6; // Set channel for character input.
  CHKOUT     = $ffc9; // CHKOUT. Define file as default output. (Must call OPEN beforehand.)
  CHRIN      = $ffcf; // Alias for BASIN.
  CHROUT     = $ffd2; // Alias for BSOUT.
  CLOSE_ALL  = $ff4a; // Close all files on a device.
  CLRCHN     = $ffcc; // Restore character I/O to screen/keyboard.
  GETIN      = $ffe4; // Get character from keyboard.

  IECIN      = $ffa5; // IECIN. Read byte from serial bus. (Must call TALK and TALKSA beforehand.)
  IECOUT     = $ffa8; // IECOUT. Write byte to serial bus. (Must call LISTEN and LSTNSA beforehand.)
  IOBASE     = $fff3; // Return start of I/O area.
  IOINIT     = $ff84; // IOINIT. Initialize CIA's, SID volume; setup memory configuration; set and start interrupt timer.
  LISTEN     = $ffb1; // Send LISTEN command to serial bus.
  LKUPLA     = $ff59; // Search tables for given LA.
  LKUPSA     = $ff5c; // Search tables for given SA.
  LOAD       = $ffd5; // LOAD. Load or verify file. (Must call SETLFS and SETNAM beforehand.)
  LSTNSA     = $ff93; // LSTNSA. Send LISTEN secondary address to serial bus. (Must call LISTEN beforehand.)
  MEMBOT     = $ff99; // MEMBOT. Save or restore start address of BASIC work area.
  MEMTOP     = $ff9c; // MEMTOP. Save or restore end address of BASIC work area.
  OPEN       = $ffc0; // OPEN. Open file. (Must call SETLFS and SETNAM beforehand.)
  PLOT       = $fff0; // PLOT. Save or restore cursor position.
  PRIMM      = $ff7d; // Print string following the callerâ€™s code.

  RAMTAS     = $ff87; // RAMTAS. Clear memory addresses $0002-$0101 and $0200-$03FF; run memory test and set start and end address of BASIC work area accordingly; set screen memory to $0400 and datasette buffer to $033C.
  RDTIM      = $ffde; // RDTIM. read Time of Day, at memory address $00A0-$00A2.
  READST     = $ffb7; // READST. Fetch status of current input/output device, value of ST variable. (For RS232, status is cleared.)
  RESTOR     = $ff8a; // RESTOR. Fill vector table at memory addresses $0314-$0333 with default values.
  SAVE       = $ffd8; // SAVE. Save file. (Must call SETLFS and SETNAM beforehand.)
  SCINIT     = $ff81; // SCINIT. Initialize VIC; restore default input/output to keyboard/screen; clear screen; set PAL/NTSC switch and interrupt timer.
  SCNKEY     = $ff9f; // SCNKEY. Query keyboard; put current matrix code into memory address $00CB, current status of shift keys into memory address $028D and PETSCII code into keyboard buffer.
  SCREEN     = $ffed; // SCREEN. Fetch number of screen rows and columns.

  SETLFS     = $ffba; // SETLFS. Set file parameters.
  SETMSG     = $ff90; // SETMSG. Set system error display switch at memory address $009D.
  SETNAM     = $ffbd; // SETNAM. Set file name parameters.
  SETTIM     = $ffdb; // SETTIM. Set Time of Day, at memory address $00A0-$00A2.
  SETTMO     = $ffa2; // SETTMO. Unknown. (Set serial bus timeout.)
  STOP       = $ffe1; // STOP. Query Stop key indicator, at memory address $0091; if pressed, call CLRCHN and clear keyboard buffer.
  TALK       = $ffb4; // TALK. Send TALK command to serial bus.
  TALKSA     = $ff96; // TALKSA. Send TALK secondary address to serial bus. (Must call TALK beforehand.)
  UDTIM      = $ffea; // UDTIM. Update Time of Day, at memory address $00A0-$00A2, and Stop key indicator, at memory address $0091.
  UNLSTN     = $ffae; // UNLSTN. Send UNLISTEN command to serial bus.
  UNTALK     = $ffab; // UNTALK. Send UNTALK command to serial bus.
  VECTOR     = $ff8d; // VECTOR. Copy vector table at memory addresses $0314-$0333 from or into user table.

// x16 specific routines
 clock_get_date_time    = $ff50; // Get the date and time.
 clock_set_date_time    = $ff4d; //	Set the date and time.
 entropy_get            = $fecf; // Get 24 random bits.
 enter_basic            = $ff47; // Enter BASIC.
 screen_mode            = $ff5f; // Get/Set screen mode.
 screen_set_charset     = $ff62; // Activate 8x8 text mode charset.

// Graphics routines
  GRAPH_init            = $ff20; // Initialize graphics.
  GRAPH_clear           = $ff23; // Clear screen.
  GRAPH_set_window      = $ff26; // Set clipping region.
  GRPAH_set_colors      = $ff29; // Set stroke, fill and background colors.
  GRAPH_draw_line       = $ff2c; // Draw a line.
  GRAPH_draw_rect       = $ff2f; // Draw a rectangle (optionally filled).
  GRAPH_move_rect       = $ff32; // Move pixels.
  GRAPH_draw_oval       = $ff35; // Draw an oval or circle.
  GRAPH_draw_image      = $ff38; // Draw an image.
  GRAPH_set_font        = $ff3b; // Set the current font.
  GRAPH_get_char_size   = $ff3e; // Get the size of a character.
  GRAPH_put_char        = $ff41; // Draw a character.

// floating point routines
  MOVFM      = $bba2; // MOVFM. Move a Floating Point Number from Memory to FAC1
  FOUT       = $bddd; // FOUT. Convert Contents of FAC1 to ASCII String
  MOV2F      = $bbc7; // MOV2F. Move a Floating Point Number from FAC1 to Memory

// interrupt routines and vectors
  IRQVECLO   = $0314; // hardware interrupt (IRQ) vector, low byte
  IRQVECHI   = $0315; // hardware interrupt (IRQ) vector, high byte
  STDIRQ     = $ea31; //start address of standard interrupt routines

// keyboard
  CURRKEY    = $cb;

; vic_spr0_x		= $D000
; vic_spr0_y		= $D001
; vic_spr1_x		= $D002
; vic_spr1_y		= $D003
; vic_spr2_x		= $D004
; vic_spr2_y		= $D005
; vic_spr3_x		= $D006
; vic_spr3_y		= $D007
; vic_spr4_x		= $D008
; vic_spr4_y		= $D009
; vic_spr5_x		= $D00A
; vic_spr5_y		= $D00B
; vic_spr6_x		= $D00C
; vic_spr6_y		= $D00D
; vic_spr7_x		= $D00E
; vic_spr7_y		= $D00F
; vic_spr_hi_x	= $D010
; vic_cr1			= $D011
; vic_raster		= $D012
; vic_lp_x		= $D013
; vic_lp_y		= $D014
; vic_spr_ena		= $D015
; vic_cr2			= $D016
; vic_spr_exp_y	= $D017
; vic_mem			= $D018
; vic_irq			= $D019
; vic_irq_ena		= $D01A
; vic_spr_dp		= $D01B
; vic_spr_mcolor	= $D01C
; vic_spr_exp_x	= $D01D
; vic_spr_ss_col	= $D01E
; vic_spr_sd_col	= $D01F
; vic_border		= $D020
; vic_bg_color0	= $D021
; vic_bg_color1	= $D022
; vic_bg_color2	= $D023
; vic_bg_color3	= $D024
; vic_spr_color1	= $D025
; vic_spr_color2	= $D026
; vic_spr0_color	= $D027
; vic_spr1_color	= $D028
; vic_spr2_color	= $D029
; vic_spr3_color	= $D02A
; vic_spr4_color	= $D02B
; vic_spr5_color	= $D02C
; vic_spr6_color	= $D02D
; vic_spr7_color	= $D02E


.macro	basic_start(addr)

	.word upstartEnd	// link address
	.word 10		// line num
	.byte $9e		// sys

	?a=0
	?b=0
	?c=0
	?d=0
	?e=0

	?v = %%addr

	ift ?v>=10000
	?a=?v/10000
	?v=?v-(?a*10000)
	eif

	ift ?v>=1000
	?b=?v/1000
	?v=?v-(?b*1000)
	eif

	ift ?v>=100
	?c=?v/100
	?v=?v-(?c*100)
	eif

	ift ?v>=10
	?d=?v/10
	?v=?v-(?d*10)
	eif

	?e=?v%10

	dta ?a+$30,?b+$30,?c+$30,?d+$30,?e+$30

	.byte 0
upstartEnd
	.word 0			// empty link signals the end of the program

.endm


//
// Switch bank in VIC-II
//
// Args:
//    bank: bank number to switch to. Valid values: 0-3.
//
.macro SwitchVICBank(bank)
    //
    // The VIC-II chip can only access 16K bytes at a time. In order to
    // have it access all of the 64K available, we have to tell it to look
    // at one of four banks.
    //
    // This is controller by bits 0 and 1 in $dd00 (PORT A of CIA #2).
    //
    //  +------+-------+----------+-------------------------------------+
    //  | BITS |  BANK | STARTING |  VIC-II CHIP RANGE                  |
    //  |      |       | LOCATION |                                     |
    //  +------+-------+----------+-------------------------------------+
    //  |  00  |   3   |   49152  | ($C000-$FFFF)*                      |
    //  |  01  |   2   |   32768  | ($8000-$BFFF)                       |
    //  |  10  |   1   |   16384  | ($4000-$7FFF)*                      |
    //  |  11  |   0   |       0  | ($0000-$3FFF) (DEFAULT VALUE)       |
    //  +------+-------+----------+-------------------------------------+
    ?bits=%11

    ift (%%bank==0)
     ?bits=%11
    eli (%%bank==1)
     ?bits=%10
    eli (%%bank==2)
     ?bits=%01
    eli (%%bank==3)
     ?bits=%00
    eif

    //
    // Set Data Direction for CIA #2, Port A to output
    //
    lda $dd02
    and #%11111100  // Mask the bits we're interested in.
    ora #$03        // Set bits 0 and 1.
    sta $dd02

    //
    // Tell VIC-II to switch to bank
    //
    lda $dd00
    and #%11111100
    ora #?bits
    sta $dd00
.endm


//
// Enter hires bitmap mode (a.k.a. standard bitmap mode)
//
.macro SetHiresBitmapMode
    //
    // Clear extended color mode (bit 6) and set bitmap mode (bit 5)
    //
    lda $d011
    and #%10111111
    ora #%00100000
    sta $d011

    //
    // Clear multi color mode (bit 4)
    //
    lda $d016
    and #%11101111
    sta $d016
.endm


//
// Enter hires bitmap mode (a.k.a. standard bitmap mode)
//
.macro SetMulticolorBitmapMode
    //
    // Clear extended color mode (bit 6) and set bitmap mode (bit 5)
    //
    lda $d011
    and #%10111111
    ora #%00100000
    sta $d011

    //
    // Clear multi color mode (bit 4)
    //
    lda $d016
    ora #%00010000
    sta $d016
.endm


//
// Switch location of screen memory.
//
// Args:
//   address: Address relative to current VIC-II bank base address.
//            Valid values: $0000-$3c00. Must be a multiple of $0400.
//
.macro SetScreenMemory(address)
    //
    // The most significant nibble of $D018 selects where the screen is
    // located in the current VIC-II bank.
    //
    //  +------------+-----------------------------+
    //  |            |         LOCATION*           |
    //  |    BITS    +---------+-------------------+
    //  |            | DECIMAL |        HEX        |
    //  +------------+---------+-------------------+
    //  |  0000XXXX  |      0  |  $0000            |
    //  |  0001XXXX  |   1024  |  $0400 (DEFAULT)  |
    //  |  0010XXXX  |   2048  |  $0800            |
    //  |  0011XXXX  |   3072  |  $0C00            |
    //  |  0100XXXX  |   4096  |  $1000            |
    //  |  0101XXXX  |   5120  |  $1400            |
    //  |  0110XXXX  |   6144  |  $1800            |
    //  |  0111XXXX  |   7168  |  $1C00            |
    //  |  1000XXXX  |   8192  |  $2000            |
    //  |  1001XXXX  |   9216  |  $2400            |
    //  |  1010XXXX  |  10240  |  $2800            |
    //  |  1011XXXX  |  11264  |  $2C00            |
    //  |  1100XXXX  |  12288  |  $3000            |
    //  |  1101XXXX  |  13312  |  $3400            |
    //  |  1110XXXX  |  14336  |  $3800            |
    //  |  1111XXXX  |  15360  |  $3C00            |
    //  +------------+---------+-------------------+
    //
    ?bits = (%%address / $0400) << 4

    lda $d018
    and #%00001111
    ora #?bits
    sta $d018
.endm


//
// Set location of bitmap.
//
// Args:
//    address: Address relative to VIC-II bank address.
//             Valid values: $0000 (bitmap at $0000-$1FFF)
//                           $2000 (bitmap at $2000-$3FFF)
//
.macro SetBitmapAddress(address)
    //
    // In standard bitmap mode the location of the bitmap area can
    // be set to either BANK address + $0000 or BANK address + $2000
    //
    // By setting bit 3, we can configure which of the locations to use.
    //

    lda $d018

    ift %%address == $0000
        and #%11110111
    eli %%address == $2000
        ora #%00001000
    eif

    sta $d018
.endm
